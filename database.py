content='from sqlalchemy import create_engine, Column, Integer, String, DateTime, Boolean\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker\nfrom datetime import datetime\nimport os\nimport logging\nfrom typing import Optional\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# Get database URL from environment variable or use default SQLite database\nDATABASE_URL = os.getenv("DATABASE_URL", "sqlite:///./test.db")\n\n# Create SQLAlchemy engine\ntry:\n    engine = create_engine(DATABASE_URL, connect_args={"check_same_thread": False})\n    logger.info("Database engine created successfully")\nexcept Exception as e:\n    logger.error(f"Failed to create database engine: {str(e)}")\n    raise\n\n# Create declarative base\nBase = declarative_base()\n\n# Create SessionLocal class\nSessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)\n\nclass User(Base):\n    __tablename__ = "users"\n\n    id = Column(Integer, primary_key=True, index=True)\n    username = Column(String, unique=True, index=True)\n    email = Column(String, unique=True, index=True)\n    hashed_password = Column(String)\n    is_active = Column(Boolean, default=True)\n    created_at = Column(DateTime, default=datetime.utcnow)\n    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)\n\ndef get_db():\n    """\n    Get database session with proper error handling\n    """\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\ndef init_db() -> None:\n    """\n    Initialize database tables\n    """\n    try:\n        Base.metadata.create_all(bind=engine)\n        logger.info("Database tables created successfully")\n    except Exception as e:\n        logger.error(f"Failed to create database tables: {str(e)}")\n        raise\n\ndef get_user_by_username(db: SessionLocal, username: str) -> Optional[User]:\n    """\n    Get user by username\n    """\n    try:\n        return db.query(User).filter(User.username == username).first()\n    except Exception as e:\n        logger.error(f"Error getting user by username: {str(e)}")\n        return None\n\ndef get_user_by_email(db: SessionLocal, email: str) -> Optional[User]:\n    """\n    Get user by email\n    """\n    try:\n        return db.query(User).filter(User.email == email).first()\n    except Exception as e:\n        logger.error(f"Error getting user by email: {str(e)}")\n        return None\n\ndef create_user(db: SessionLocal, username: str, email: str, hashed_password: str) -> Optional[User]:\n    """\n    Create new user\n    """\n    try:\n        db_user = User(\n            username=username,\n            email=email,\n            hashed_password=hashed_password\n        )\n        db.add(db_user)\n        db.commit()\n        db.refresh(db_user)\n        return db_user\n    except Exception as e:\n        logger.error(f"Error creating user: {str(e)}")\n        db.rollback()\n        return None\n\ndef update_user(db: SessionLocal, user_id: int, **kwargs) -> Optional[User]:\n    """\n    Update user details\n    """\n    try:\n        user = db.query(User).filter(User.id == user_id).first()\n        if user:\n            for key, value in kwargs.items():\n                setattr(user, key, value)\n            user.updated_at = datetime.utcnow()\n            db.commit()\n            db.refresh(user)\n        return user\n    except Exception as e:\n        logger.error(f"Error updating user: {str(e)}")\n        db.rollback()\n        return None\n\ndef delete_user(db: SessionLocal, user_id: int) -> bool:\n    """\n    Delete user\n    """\n    try:' additional_kwargs={} response_metadata={'id': 'msg_01M8szZVvYm9CiRgcciGLiLm', 'model': 'claude-3-5-sonnet-20241022', 'stop_reason': 'max_tokens', 'stop_sequence': None, 'usage': {'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0, 'input_tokens': 334, 'output_tokens': 1024, 'service_tier': 'standard'}} id='run--cb87f779-3790-43ae-a937-f40c8ea32910-0' usage_metadata={'input_tokens': 334, 'output_tokens': 1024, 'total_tokens': 1358, 'input_token_details': {'cache_read': 0, 'cache_creation': 0}}