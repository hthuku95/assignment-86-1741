content='import jwt\nfrom datetime import datetime, timedelta\nfrom typing import Optional\nfrom fastapi import HTTPException, Security, Depends\nfrom fastapi.security import HTTPBearer, HTTPAuthorizationCredentials\nfrom passlib.context import CryptContext\nfrom config import JWT_SECRET_KEY, JWT_ALGORITHM, ACCESS_TOKEN_EXPIRE_MINUTES\n\npwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")\nsecurity = HTTPBearer()\n\nclass AuthHandler:\n    def __init__(self):\n        self.secret_key = JWT_SECRET_KEY\n        self.algorithm = JWT_ALGORITHM\n\n    def get_password_hash(self, password: str) -> str:\n        """Generate password hash using bcrypt."""\n        return pwd_context.hash(password)\n\n    def verify_password(self, plain_password: str, hashed_password: str) -> bool:\n        """Verify password against hashed password."""\n        try:\n            return pwd_context.verify(plain_password, hashed_password)\n        except Exception:\n            return False\n\n    def create_access_token(self, user_id: str, expires_delta: Optional[timedelta] = None) -> str:\n        """Create JWT access token."""\n        try:\n            payload = {\n                "sub": str(user_id),\n                "iat": datetime.utcnow(),\n                "type": "access_token"\n            }\n            \n            if expires_delta:\n                expire = datetime.utcnow() + expires_delta\n            else:\n                expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n            \n            payload.update({"exp": expire})\n            \n            return jwt.encode(payload, self.secret_key, algorithm=self.algorithm)\n        except Exception as e:\n            raise HTTPException(\n                status_code=500,\n                detail=f"Error creating access token: {str(e)}"\n            )\n\n    def decode_token(self, token: str) -> dict:\n        """Decode and validate JWT token."""\n        try:\n            payload = jwt.decode(token, self.secret_key, algorithms=[self.algorithm])\n            if payload.get("type") != "access_token":\n                raise HTTPException(\n                    status_code=401,\n                    detail="Invalid token type"\n                )\n            return payload\n        except jwt.ExpiredSignatureError:\n            raise HTTPException(\n                status_code=401,\n                detail="Token has expired"\n            )\n        except jwt.InvalidTokenError:\n            raise HTTPException(\n                status_code=401,\n                detail="Invalid token"\n            )\n\n    def auth_wrapper(self, auth: HTTPAuthorizationCredentials = Security(security)) -> dict:\n        """Wrapper for token authentication."""\n        return self.decode_token(auth.credentials)\n\n    def get_current_user_id(self, auth: HTTPAuthorizationCredentials = Security(security)) -> str:\n        """Extract user ID from token."""\n        payload = self.decode_token(auth.credentials)\n        return payload.get("sub")\n\nauth_handler = AuthHandler()\n\ndef get_current_user_id(credentials: HTTPAuthorizationCredentials = Security(security)) -> str:\n    """Dependency to get current user ID from token."""\n    return auth_handler.get_current_user_id(credentials)\n\ndef verify_token(credentials: HTTPAuthorizationCredentials = Security(security)) -> dict:\n    """Dependency to verify token and return payload."""\n    return auth_handler.decode_token(credentials.credentials)' additional_kwargs={} response_metadata={'id': 'msg_01R4Z1Q7iRb8CrGG8p737fsp', 'model': 'claude-3-5-sonnet-20241022', 'stop_reason': 'end_turn', 'stop_sequence': None, 'usage': {'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0, 'input_tokens': 335, 'output_tokens': 855, 'service_tier': 'standard'}} id='run--dba1b556-243e-45fb-98bf-9e64ffadac7d-0' usage_metadata={'input_tokens': 335, 'output_tokens': 855, 'total_tokens': 1190, 'input_token_details': {'cache_read': 0, 'cache_creation': 0}}