content='import logging\nimport os\nfrom datetime import datetime, timedelta\nfrom typing import Optional\n\nfrom fastapi import Depends, FastAPI, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm\nfrom jose import JWTError, jwt\nfrom passlib.context import CryptContext\nfrom pydantic import BaseModel\nfrom sqlalchemy.orm import Session\n\nfrom database import SessionLocal, engine, Base\nimport models\nimport schemas\n\n# Initialize logging\nlogging.basicConfig(\n    level=logging.INFO,\n    format=\'%(asctime)s - %(name)s - %(levelname)s - %(message)s\'\n)\nlogger = logging.getLogger(__name__)\n\n# Create database tables\nBase.metadata.create_all(bind=engine)\n\napp = FastAPI(\n    title="Final Success Test API",\n    description="Simple FastAPI with user authentication and database operations",\n    version="1.0.0"\n)\n\n# Security configuration\nSECRET_KEY = os.getenv("SECRET_KEY", "your-secret-key-here")\nALGORITHM = "HS256"\nACCESS_TOKEN_EXPIRE_MINUTES = 30\n\npwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")\noauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")\n\n# Dependency to get DB session\ndef get_db():\n    db = SessionLocal()\n    try:\n        yield db\n    finally:\n        db.close()\n\ndef verify_password(plain_password: str, hashed_password: str):\n    return pwd_context.verify(plain_password, hashed_password)\n\ndef get_password_hash(password: str):\n    return pwd_context.hash(password)\n\ndef create_access_token(data: dict, expires_delta: Optional[timedelta] = None):\n    to_encode = data.copy()\n    if expires_delta:\n        expire = datetime.utcnow() + expires_delta\n    else:\n        expire = datetime.utcnow() + timedelta(minutes=15)\n    to_encode.update({"exp": expire})\n    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n    return encoded_jwt\n\nasync def get_current_user(token: str = Depends(oauth2_scheme), db: Session = Depends(get_db)):\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail="Could not validate credentials",\n        headers={"WWW-Authenticate": "Bearer"},\n    )\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        username: str = payload.get("sub")\n        if username is None:\n            raise credentials_exception\n    except JWTError:\n        raise credentials_exception\n    user = db.query(models.User).filter(models.User.username == username).first()\n    if user is None:\n        raise credentials_exception\n    return user\n\n@app.post("/token", response_model=schemas.Token)\nasync def login_for_access_token(\n    form_data: OAuth2PasswordRequestForm = Depends(),\n    db: Session = Depends(get_db)\n):\n    user = db.query(models.User).filter(models.User.username == form_data.username).first()\n    if not user or not verify_password(form_data.password, user.hashed_password):\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail="Incorrect username or password",\n            headers={"WWW-Authenticate": "Bearer"},\n        )\n    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n    access_token = create_access_token(\n        data={"sub": user.username}, expires_delta=access_token_expires\n    )\n    return {"access_token": access_token, "token_type": "bearer"}\n\n@app.post("/users/", response_model=schemas.User)\ndef create_user(user: schemas.UserCreate, db: Session = Depends(get_db)):\n    db_user = db.query(models.User).filter(models.User.username == user.username).first()\n    if db_user:' additional_kwargs={} response_metadata={'id': 'msg_01JS4BAh8NvPNkh54MAPFCHg', 'model': 'claude-3-5-sonnet-20241022', 'stop_reason': 'max_tokens', 'stop_sequence': None, 'usage': {'cache_creation_input_tokens': 0, 'cache_read_input_tokens': 0, 'input_tokens': 338, 'output_tokens': 1024, 'service_tier': 'standard'}} id='run--8a50e63e-864a-4ed2-8f50-1b3de60d17fc-0' usage_metadata={'input_tokens': 338, 'output_tokens': 1024, 'total_tokens': 1362, 'input_token_details': {'cache_read': 0, 'cache_creation': 0}}